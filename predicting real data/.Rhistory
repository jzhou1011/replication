patient.data  # notice not sorted by IDs
patient.data[c(1, 4, 2, 3, 6, 5), ]  # I can sort manually this way. Not ideal if I have a lot of data!
patient.data$ID  # this is a vector, right?
order(patient.data$ID)  # notice! Identical to the order I gave manually
patient.data[order(patient.data$ID), ]  # nice!
#factors is a datatype that reprensts catagorical data.
rank(patient.data$ID)  # who can tell the difference between order and rank? Look at the output!
sort(patient.data$ID)  # useful only to sort vectors
# head and tail of a dataset
data(iris)  # example dataset pre-built into R
iris
head(iris)  # top 6 rows
tail(iris)  # bottom 6 rows
head(iris, 10)  # top 10 rows
# get info on object - VERY useful
class(iris)
summary(iris)
str(iris)
# convert data frame to matrix
as.matrix(iris)
data.matrix(iris)  # can you tell me what the difference is?
str(as.matrix(iris))
str(data.matrix(iris))
# tomorrow: loading and saving data frames from/to text files!
## Missing values
v <- c(2, 6, 10, NA, 3)
sum(v)  # this doesn't work. why?
sum(v, na.rm=T)  # if you remove missing values, it works
is.na(v)  # which elements are NAs?
any(is.na(v))
v[is.na(v)] <- 0  # you can impute a value (that makes sense) in missing cells
v
sum(v)  # now it works
## Session: objects, saving
ls()  # all the objects we created today
rm(x)  # delete one object
ls()
rm(list=c("y", "a"))  # delete many objects - notice that the list of objects is provided as a character vector
ls()
save.image("day1.RData")  # I don't want to lose the data I have generated so far
# optional
# save(my.matrix, file="matrix.RData")  # this saves selected objects
savehistory()  # save history of commands. Note that there is no dot in between save and history, unlike save.image - these are the inconsistencies that make the language ugly sometimes
q()  # quit R
round(5.42552, digits=2)  # 5.43
# remember to save this R file every now and then!
## Variables
a
a <- 3384917922  # note that assignment is <- symbol
a
test = 3454  # = also works in this example, but strongly discouraged (trust me on this)
test
#use the arrow one and not the = beucase u get erros... WHY
#?sqrt tells u things
a
A  # This won't work: R is case-sensitive!
a + 2
a + 5
b <- 56 + (67 / 12) * sqrt(7)  # use parentheses to do the math right!
b
b <- b + a
b
a
## Vectors (unidimensional arrays where each element has the same mode)
my.num.vector <- c(1, 5, 8, 10)  # c = combine, used to make vectors
my.num.vector  # work faster: use TAB to autocomplete, or the arrow keys!
my.seq.vector <- 5:26  # from 5 to 26
my.seq.vector
rev(my.seq.vector)  # reverse order
26:5  # this also works
my.empty.vector <- vector(mode="numeric", length=10)
my.empty.vector
my.scalar <- 1  # scalars are one-element vectors
# work on specific elements of vectors
my.num.vector
my.num.vector[3]  # third element - note the square brackets!
my.num.vector[2:4]  # second to fourth element
my.num.vector[1, 3]  # this doesn't work - why?
my.num.vector[c(1, 3)]  # first and third element - this works!
my.num.vector[c(-1, -3)]  # everything except first and third element
my.num.vector  # original vector is unchanged
my.small.vector <- my.num.vector[2:4]  # can save what I extract into another vector
my.num.vector[2] <- 7  # not only extract, you can also EDIT specific elements!
my.num.vector
my.small.vector
my.small.vector <- c(my.small.vector, 7)  # add an extra element at the end of your vector
my.small.vector
my.small.vector[5:6] <- c(12, 14)  # this is another way. Note that many languages would give an error for something like this, but not R
my.small.vector
# functions to automatically generate lists of numbers
seq(-30, 30, by = 2)  # all even numbers from -30 to 30
seq(-30, 30, length.out=10)  # 10 numbers evenly spaced between -30 to 30
rep(c(1, 2, 3, 4), times=6)  # repeat the sequence 1 2 3 4 six times
rep(c(1, 2, 3, 4), each=6)  # repeat 1 six times, then 2 six times, etc
# associate names to vector elements
my.num.vector
names(my.num.vector)  # names is a vector itself!
names(my.num.vector) <- c("1st #", "2nd #", "3rd #", "4th #")  # note the double quotes - we are providing characters, not numbers!
names(my.num.vector)
names(my.num.vector)[3]  # if names is a vector, I can extract elements!
names(my.num.vector[3])  # this is an alternative
my.num.vector
length(my.num.vector)
max(my.num.vector)
min(my.num.vector)
which.max(my.num.vector)  # rather than the max value, get the position of the max value
which.min(my.num.vector)  # same for min
sum(my.num.vector)
## Matrices (two-dimension arrays where each element has the same mode)
my.matrix <- matrix(nrow=2, ncol=3)
my.matrix  # this is empty! (more precisely, filled in with NAs)
my.matrix[2, 3]  # element at second row, third column (ALWAYS: row, column)
my.matrix[2, 3] <- 5
my.matrix  # not empty anymore
my.matrix[2, ]  # entire second row - note, result is a vector
my.matrix[2, ][3]  # so I can ask the third element of the second row
my.matrix[2, 3]  # equivalent, more straightforward way (again: row, column)
my.matrix[, 3]  # entire third column
my.matrix[2, c(2, 3)]  # second row, and last two columns
dim(my.matrix)  # result is number of rows and number of columns
nrow(my.matrix)
ncol(my.matrix)
rownames(my.matrix)  # empty
rownames(my.matrix) <- c("first row", "second row")
rownames(my.matrix)
colnames(my.matrix)
colnames(my.matrix) <- c("first column", "second column")  # error! why?
ncol(my.matrix)
colnames(my.matrix) <- c("first column", "second column", "third column")
colnames(my.matrix)
colnames(my.matrix)[2]
# build matrices by binding rows or columns
x <- 1:3
y <- 10:12
x
y
my.row.matrix <- rbind(x, y)  # rbind = row binding
my.row.matrix
my.col.matrix <- cbind(x, y)  # cbind = column binding
my.col.matrix
# build matrices by providing elements from a vector
my.matrix <- matrix(c(1, 3, 5, 6:8), ncol=3, byrow=TRUE)  # 6-element vector, 3 columns, how many rows? Necessarily 2! And we fill matrix by row (default is by column)
my.matrix
t(my.matrix)  # transpose (swaps rows and columns)
## Arrays (n-dimension arrays where each elements has the same mode)
z <- array(1:24, dim=c(2, 3, 4))  # 24-element vector, and array is 2 by 3 by 4
z
## Atomic classes
my.num.vector <- c(1, 5, 8, 10)  # data type numeric (real number)
my.str.vector <- c("my", "dear", "friend")  # data type character
my.log.vector <- c(TRUE, FALSE, FALSE, T, F)  # data type logical. Notice that T=TRUE and F=FALSE
my.log.vector
my.log.vector <- c(true, FALSE)  # this won't work - why?
my.log.vector  # so my.log.vector is unchanged
my.int.vector <- c(1L, 450L)  # data type integer (discrete) - not frequently used
my.unknown.vector <- c("a", 4, TRUE)  # what if you mix and match? Elements coerced to data type that makes most sense
my.unknown.vector
# ask vector class
class(my.unknown.vector)  # tells you it's a character vector!
class(my.str.vector)
class(my.int.vector)
# ask for a specific type
is.numeric(my.num.vector)
is.character(my.num.vector)
is.character(my.str.vector)
# optional
# is.logical(x)
# is.integer(x)
# convert from a type to another
once.num <- as.character(my.num.vector)
my.num.vector
once.num  # notice the double quotes in the output
class(my.num.vector)
class(once.num)
as.numeric(my.str.vector)  # cannot do impossible things!
as.numeric(once.num)  # this works because it makes sense
# optional
# as.logical(x)
# as.integer(x)
# as.complex(x)
## Vectorized operations - Faster for you to write, and faster for R to execute
my.matrix
my.matrix + 1  # matrix and scalar: no need to write the same addition six times for each of the matrix elements
my.matrix * 2
my.matrix + my.matrix[1, ]  # things may not always work out as expected. Be careful!
my.matrix * my.matrix  # element-wise multiplication
x <- 1:4; y <- c(1, 6)  # two commands on the same line with semicolon
x * y  # element-wise multiplication returns 1*1, 2*6, 3*1, 4*6 (recycles the second vector) - note there is no error! Careful!!!!
# optional: true inner matrix multiplication
# my.matrix %*% my.matrix  # true inner matrix multiplication - does not work (incompatible dimensions)
# my.matrix %*% t(my.matrix)  # this works because ncol of 1st matrix = nrow of 2nd matrix. 1,1 element: 1*1 + 3*3 + 5*5; 1,2 element: 1*6 + 3*7 + 5*8; and so on
## Boolean operations
x < 3
less3 <- x < 3
less3  # notice that result is a logical vector
less3[4]
(x < 3)[4]  # this works as well, if you didn't want to assign to a variable
x == 2  # notice the double equal sign to distinguish from assignments
which(x == 2)  # converts boolean to index - in other words, tell you the position of what is true!
sum(x < 3)  # counts how many elements of x are less than 3; looks weird, but it makes sense if you think that FALSE = 0 and TRUE = 1
4 != 5  # are 4 and 5 different?
4 %in% x  # is 4 in x?
c(2, 8) %in% x  # are those two numbers in x?
match(c(2, 8), x)  # but where are 2 and 8 in x?
any(x > 4)
all(x < 2)
# And, Or, Not
3 > 2 & 5 < 4  # And - TRUE if all are TRUE
3 > 2 | 5 < 4  # Or - TRUE if any is TRUE
!(4 != 5)  # Not - this results in F
x < 4 & x > 2
# filter data using logical operations
x
less3
x[3]  # remember this?
which(less3)  # well, this is a vector as well, with positions
all.equal(which(less3), c(1, 2))  # proved!
x[which(less3)]  # so does this work? Shows only TRUE elements!
x[less3]  # this works too! Rather than providings indeces, I provide a vector of TRUE/FALSE and subset only elements matching TRUEs!
sum(x[x > 2])  # so now I can do math on subsets
#one is that we want to keep the data and 0 is we don't want to keep the data
#it automatically knows when u index with T, ,F it's about keeping or not keeping
## Data Frames (two-dimension data structures where each column may have a different mode = TABLES)
#data frame - supercharged excel sheet. combines data across mixed types
patient.id <- c(10, 20, 30)
age <- c(25, 34, 28)
diabetes <- c("T1", "T2", "T1")
patient.data <- data.frame(patient.id, age, diabetes, status)
nrow(patient.data)
ncol(patient.data)
dim(patient.data)  # rows and columns
patient.data[1:2]  # 1st and 2nd columns
patient.data[c("diabetes", "status")]  # select columns by name
patient.data$age  # dollar sign convenient way to select columns - no double quotes! output returned as a vector
patient.data[patient.data$age == 28]  # not the right output! why?
patient.data[patient.data$age == 28, ]  # this works! We needed to tell which columns to retain (in this example, all of them)
patient.data[patient.data$age == 28, 3]  # filter both rows and columns
subset(patient.data, subset=age > 1 & age < 30, select = -status)
names(patient.data)
colnames(patient.data)
rownames(patient.data)
colnames(patient.data)[c(1, 3)] <- c("ID", "type")
patient.data
patient.data$new.var <- rep(0, nrow(patient.data))  # assigning an unknown column will create it
patient.data
patient.data <- cbind(patient.data, second.var=rep(0, nrow(patient.data)))  # you can also add a column by binding it
patient2 <- patient.data  # what about adding new rows? Less easy. Let's start
patient2$ID <- c(15, 78, 40)
patient2
patient.data <- rbind(patient.data, patient2)  # the two data frames must have the same structure!
patient.data
patient3 <- patient2
colnames(patient3)[3] <- "test"
patient3
rbind(patient.data, patient3)  # doesn't work (mismatch column names)
# sorting
patient.data  # notice not sorted by IDs
patient.data[c(1, 4, 2, 3, 6, 5), ]  # I can sort manually this way. Not ideal if I have a lot of data!
patient.data$ID  # this is a vector, right?
order(patient.data$ID)  # notice! Identical to the order I gave manually
patient.data[order(patient.data$ID), ]  # nice!
#factors is a datatype that reprensts catagorical data.
rank(patient.data$ID)  # who can tell the difference between order and rank? Look at the output!
sort(patient.data$ID)  # useful only to sort vectors
# head and tail of a dataset
data(iris)  # example dataset pre-built into R
iris
head(iris)  # top 6 rows
tail(iris)  # bottom 6 rows
head(iris, 10)  # top 10 rows
# get info on object - VERY useful
class(iris)
summary(iris)
str(iris)
# convert data frame to matrix
as.matrix(iris)
data.matrix(iris)  # can you tell me what the difference is?
str(as.matrix(iris))
str(data.matrix(iris))
# tomorrow: loading and saving data frames from/to text files!
## Missing values
v <- c(2, 6, 10, NA, 3)
sum(v)  # this doesn't work. why?
sum(v, na.rm=T)  # if you remove missing values, it works
is.na(v)  # which elements are NAs?
any(is.na(v))
v[is.na(v)] <- 0  # you can impute a value (that makes sense) in missing cells
v
sum(v)  # now it works
## Session: objects, saving
ls()  # all the objects we created today
rm(x)  # delete one object
ls()
rm(list=c("y", "a"))  # delete many objects - notice that the list of objects is provided as a character vector
ls()
save.image("day1.RData")  # I don't want to lose the data I have generated so far
# optional
# save(my.matrix, file="matrix.RData")  # this saves selected objects
savehistory()  # save history of commands. Note that there is no dot in between save and history, unlike save.image - these are the inconsistencies that make the language ugly sometimes
q()  # quit R
filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
data<-read.csv(filename, sep=",")
setwd("~/Documents/Big summer/repProjColab/predicting real data")
filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
data<-read.csv(filename, sep=",")
thresh<-data$p.thresh
thresholdZscore<-qnorm(thresh),lower.tail =FALSE)
thresh<-data$p.thresh
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
thresh<-data$p.thresh[1]
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
thresh
thresholdZscore
M<-0.05/thresh
M
MPrime<-nrow(data)
MPrime
#MLE sigmasqaured
filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
data<-read.csv(filename, sep=",")
#find test statsitic
results.data<-data.frame(data$beta.disc, data$se.disc)
results.data$s1<-(data$beta.disc)/(data$se.disc)
results.data$s2<-(data$beta.rep)/(data$se.rep)
View(results.data)
?dnorm
thresh<-data$p.thresh[1]
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
M<-0.05/thresh
MSig<-nrow(data)
var<-5
estimate<-1
for(i in results.data$s1){
estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate<-1
for(i in results.data$s1){
print(i)
estimate*dnorm(i, mean=0, sd=sqrt(var))
}
dnorm(4.3, mean=0, sd=sqrt(var))
#MLE sigmasqaured
filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
data<-read.csv(filename, sep=",")
#find test statsitic
results.data<-data.frame(data$beta.disc, data$se.disc)
results.data$s1<-(data$beta.disc)/(data$se.disc)
results.data$s2<-(data$beta.rep)/(data$se.rep)
thresh<-data$p.thresh[1]
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
M<-0.05/thresh
MSig<-nrow(data)
var<-5
estimate<-1
for(i in results.data$s1){
#print(i)
estimate<-estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate*dnorm(3, mean=0, sd=sqrt(var))
3.764134e-41*dnorm(4, mean=0, sd=sqrt(var))
estimate<-estimate*pnorm(thresholdZscore, mean=0, sd=sqrt(var))
estimate<-estimate*(pnorm(thresholdZscore, mean=0, sd=sqrt(var)))^(M-Msig)
#MLE sigmasqaured
filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
data<-read.csv(filename, sep=",")
#find test statsitic
results.data<-data.frame(data$beta.disc, data$se.disc)
results.data$s1<-(data$beta.disc)/(data$se.disc)
results.data$s2<-(data$beta.rep)/(data$se.rep)
thresh<-data$p.thresh[1]
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
M<-0.05/thresh
MSig<-nrow(data)
var<-5
estimate<-1
for(i in results.data$s1){
#print(i)
estimate<-estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate<-estimate*(pnorm(thresholdZscore, mean=0, sd=sqrt(var)))^(M-Msig)
MSig<-NROW(data)
MSig<-nrow(data)
var<-5
estimate<-1
for(i in results.data$s1){
#print(i)
estimate<-estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate<-estimate*(pnorm(thresholdZscore, mean=0, sd=sqrt(var)))^(M-MSig)
View(data)
traitVar<-data$trait.var[1]
max<-0
for(i in seq(from=1, to=traitVar, by=.1)){
temp<-MLE(i)
if (temp>max) {
max<-temp
}
}
MLE<-function(var){
estimate<-1
for(i in results.data$s1){
estimate<-estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate<-estimate*(pnorm(thresholdZscore, mean=0, sd=sqrt(var)))^(M-MSig)
}
max<-0
for(i in seq(from=1, to=traitVar, by=.1)){
temp<-MLE(i)
if (temp>max) {
max<-temp
}
}
max<-0
maxVar<-0;
for(i in seq(from=1, to=traitVar, by=.1)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
max<-0
maxVar<-0;
for(i in seq(from=1, to=traitVar, by=.01)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
max<-0
maxVar<-0;
for(i in seq(from=1, to=10, by=.01)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
for(i in seq(from=1, to=100, by=.01)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
for(i in seq(from=1, to=1000, by=.01)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
for(i in seq(from=1, to=10000, by=.01)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
maxVar-1
for(i in seq(from=1, to=100, by=.001)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
?cat()
?paste
#MLE sigmasqaured
#filename<-"./files/1_19557161_data_upbuilt_filtered_upbuilt.csv" #average #6 vs 24.31
args = commandArgs(trailingOnly=TRUE)
filename<-args[1]
data<-read.csv(filename, sep=",")
#find test statsitic
results.data<-data.frame(data$beta.disc, data$se.disc)
results.data$s1<-(data$beta.disc)/(data$se.disc)
results.data$s2<-(data$beta.rep)/(data$se.rep)
thresh<-data$p.thresh[1]
thresholdZscore<-qnorm(thresh,lower.tail =FALSE)
M<-0.05/thresh
MSig<-nrow(data)
traitVar<-data$trait.var[1]
var<-5
MLE<-function(var){
estimate<-1
for(i in results.data$s1){
estimate<-estimate*dnorm(i, mean=0, sd=sqrt(var))
}
estimate<-estimate*(pnorm(thresholdZscore, mean=0, sd=sqrt(var)))^(M-MSig)
}
max<-0
maxVar<-0;
# for(i in seq(from=1, to=traitVar, by=.01)){
#   temp<-MLE(i)
#   if (temp>max) {
#     max<-temp
#     maxVar<-i
#   }
# }
for(i in seq(from=1, to=100, by=.001)){
temp<-MLE(i)
if (temp>max) {
max<-temp
maxVar<-i
}
}
results <- paste(as.character(maxVar), max, sep="  ")
cat(maxVar)
results <- paste(as.character(maxVar), max, sep="  ")
cat(results)
