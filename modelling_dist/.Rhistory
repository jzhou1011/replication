lambda <- rnorm(n=N, mean=0, sd=sigma)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lambda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lambda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lambda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#the predicted lambda is the lambda that we predict using the multivariate distribution of lambda and s1 (given s1)
compute_mean <- function(s1){
sigma^2*s1/(1+sigma^2)
}
results.data$pred_lambda <- compute_mean(results.data$s1)
s1_val <- results.data[c("lambda","s1")]
s1_val$grouping = rep("s1",10000)
colnames(s1_val) = c("lambda","value")
pred_val <- results.data[c("lambda","pred_lambda")]
pred_val$grouping = rep("pred",10000)
colnames(pred_val) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val)
colnames(result.sp.data) <- c("lambda","value","grouping")
trueVSpred<-ggplot(data = result.sp.data, mapping = aes(x = lambda, y =value, colour=(result.sp.data$grouping)))+
geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
#trueVSpred<-ggplot(data = results.data, mapping = aes(x = lambda, y = s1_pred)) +geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
#regression line
lm(formula = results.data$s1 ~ results.data$lambda)
lm(formula = results.data$s1 ~ results.data$pred_lambda)
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
#pulling lambda from normal distrubtion
sigma<-sqrt(2)
N=10000
sampleSize=10000
lambda <- rnorm(n=N, mean=0, sd=sigma)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lambda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lambda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lambda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#the predicted lambda is the lambda that we predict using the multivariate distribution of lambda and s1 (given s1)
compute_mean <- function(s1){
sigma^2*s1/(1+sigma^2)
}
results.data$pred_lambda <- compute_mean(results.data$s1)
s1_val <- results.data[c("lambda","s1")]
s1_val$grouping = rep("s1",10000)
colnames(s1_val) = c("lambda","value")
pred_val <- results.data[c("lambda","pred_lambda")]
pred_val$grouping = rep("pred",10000)
colnames(pred_val) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val)
colnames(result.sp.data) <- c("lambda","value","grouping")
trueVSpred<-ggplot(data = result.sp.data, mapping = aes(x = lambda, y =value, colour=(result.sp.data$grouping)))+
geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
#trueVSpred<-ggplot(data = results.data, mapping = aes(x = lambda, y = s1_pred)) +geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
#regression line
lm(formula = results.data$s1 ~ results.data$lambda)
lm(formula = results.data$s1 ~ results.data$pred_lambda)
#root squared mean
#given lambda what are the observed results..
result.sp.data$trues1<-true_lambda(result.sp.data$lambda)
RMSE<- function(p, o){
#p=predicted values
#o=observed
sqrt(mean((p - o)^2))
}
View(result.sp.data)
View(result.sp.data)
View(results.data)
View(results.data)
z<-RMSE(filter(result.sp.data$value,grouping==s1))
z<-RMSE(filter(result.sp.data$value,grouping=="s1"))
# OBJECTIVES
# 1) install tidyverse
# 2) tidyverse basics
# 3) visualize our data
# install tidyverse + some data
install.packages("tidyverse")
install.packages("nycflights13")
install.packages("cowplot")
# load tidyverse + flight data
library(tidyverse)
library(nycflights13)
# load cars data
data(mpg)
head(mpg)
filter(mpg, cyl == 6)
filter(result.sp.data,grouping=="s1")
z<-RMSE(filter(result.sp.data,grouping=="s1")$value, result.sp.data$trues1)
RMSE_s2<-RMSE(filter(result.sp.data,grouping=="s2")$value, result.sp.data$trues1)
RMSE_s1<-RMSE(filter(result.sp.data,grouping=="s1")$value, result.sp.data$trues1)
RMSE_s2<-RMSE(filter(result.sp.data,grouping=="s2")$value, result.sp.data$trues1)
View(results.data)
View(results.data)
RMSE_sampled_Lambda<-RMSE(results.data$s1,results.data$lambda)
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
#pulling lambda from normal distrubtion
sigma<-sqrt(2)
N=10000
sampleSize=10000
lambda <- rnorm(n=N, mean=0, sd=sigma)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lambda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lambda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lambda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#the predicted lambda is the lambda that we predict using the multivariate distribution of lambda and s1 (given s1)
compute_mean <- function(s1){
sigma^2*s1/(1+sigma^2)
}
results.data$pred_lambda <- compute_mean(results.data$s1)
s1_val <- results.data[c("lambda","s1")]
s1_val$grouping = rep("s1",10000)
colnames(s1_val) = c("lambda","value")
pred_val <- results.data[c("lambda","pred_lambda")]
pred_val$grouping = rep("pred",10000)
colnames(pred_val) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val)
colnames(result.sp.data) <- c("lambda","value","grouping")
trueVSpred<-ggplot(data = result.sp.data, mapping = aes(x = lambda, y =value, colour=(result.sp.data$grouping)))+
geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
#trueVSpred<-ggplot(data = results.data, mapping = aes(x = lambda, y = s1_pred)) +geom_point()+scale_y_continuous(breaks=seq(-8, 8, 1), limits=c(-8,8))+scale_x_continuous(breaks=seq(-8, 8, 1), limits=c(-8, 8))+ stat_function(fun=true_lambda,geom="line",colour="blue")
View(results.data)
lm(formula = results.data$s1 ~ results.data$lambda)
lm(formula = results.data$s1 ~ results.data$pred_lambda)
lm(formula = results.data$s1 ~ results.data$lambda)
lm(formula = results.data$pred_lambda ~ results.data$lambda)
RMSE_sampled_Lambda<-RMSE(results.data$lambda,results.data$s1)
RMSE<- function(t, o){
#t=theoretical
#o=observed
sqrt(mean((t - o)^2))
}
RMSE_sampled_Lambda<-RMSE(results.data$lambda,results.data$s1)
RMSE_pred_Lambda<-RMSE(result.sp.data$lambda, filter(result.sp.data,grouping=="pred")$value)
lm(formula = results.data$s1 ~ results.data$lambda)
lm(formula = results.data$pred_lambda ~ results.data$lambda)
compute_mean_square <- function(s1){
sqrt(sigma^2/(1+sigma^2))*s1
}
s1_val <- results.data[c("lambda","s1")]
s1_val$grouping = rep("s1",10000)
colnames(s1_val) = c("lambda","value")
pred_val <- results.data[c("lambda","pred_lambda")]
pred_val$grouping = rep("pred",10000)
colnames(pred_val) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val)
pred_lambda_sq <- results.data[c("lambda","pred_lambda_sqrt")]
pred_lambda_sq$grouping<- rep("sqrt",10000)
colnames(pred_lambda_sq) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val,pred_lambda_sq)
colnames(result.sp.data) <- c("lambda","value","grouping")
results.data$pred_lambda_sqrt <- compute_mean_square(results.data$s1)
results.data$pred_lambda_sqrt <- compute_mean_square(results.data$s1)
s1_val <- results.data[c("lambda","s1")]
s1_val$grouping = rep("s1",10000)
colnames(s1_val) = c("lambda","value")
pred_val <- results.data[c("lambda","pred_lambda")]
pred_val$grouping = rep("pred",10000)
colnames(pred_val) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val)
pred_lambda_sq <- results.data[c("lambda","pred_lambda_sqrt")]
pred_lambda_sq$grouping<- rep("sqrt",10000)
colnames(pred_lambda_sq) = c("lambda","value")
result.sp.data <- rbind(s1_val,pred_val,pred_lambda_sq)
colnames(result.sp.data) <- c("lambda","value","grouping")
RMSE_pred_Lambda<-RMSE(result.sp.data$lambda, filter(result.sp.data,grouping=="sqrt")$value)
RMSE_sqrt<-RMSE(result.sp.data$lambda, filter(result.sp.data,grouping=="sqrt")$value)
RMSE_pred_Lambda<-RMSE(result.sp.data$lambda, filter(result.sp.data,grouping=="pred")$value)
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
tempSd<-sqrt(2)
N=10000
sampleSize=10000
lamda <- rnorm(n=N, mean=0, sd=tempSd)
#to check if the lamda drawn is normally ditrbuted
den_init_lambda <- density(lamda)
plot(den_init_lambda)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
View(results.data)
View(results.data)
calculate_prob<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-pnorm(5.2, mean, sqrt(var))
return(p)
}
s1_greater<-nrow(filter(results.data, s1>5.2))
s1_greater
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
3/14
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
integrate(calculate_pcondtional, lower=5.2, upper=Inf)
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=tempSd)
#to check if the lamda drawn is normally ditrbuted
den_init_lambda <- density(lamda)
plot(den_init_lambda)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#probability of s2 replicating given s1
#the the two are multivate normal so we can use the equation
#each s1 has a different distbrution for s2 will be and then we want the probability of that replicating
calculate_pcondtional<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-pnorm(5.2, mean, sqrt(var))
return(p)
}
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))
}
integrand <- function(s1){
calculate_pcondtional(s1)*calculate_pstudy1(s1)
}
integrate(calculate_pcondtional, lower=5.2, upper=Inf)
calculate_pcondtional(6)
calculate_pcondtional(5.2)
calculate_pcondtional(8)
calculate_pcondtional(5.2)
calculate_pcondtional(8)
calculate_pcondtional<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-1-pnorm(5.2, mean, sqrt(var))
return(p)
}
calculate_pcondtional(8)
calculate_pcondtional(5.2)
integrate(calculate_pcondtional, lower=5.2, upper=Inf)
calculate_pcondtional(5.2)
calculate_pcondtional(9)
calculate_pcondtional(10)
calculate_pcondtional(30)
?dnorm
calculate_pstudy1(5.2)
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))*s1
}
calculate_pstudy1(5.2)
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))*s1
}
integrate(calculate_pcondtional, lower=5.2, upper=Inf)
integrate(integrand, lower=5.2, upper=Inf)
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))
}
integrand <- function(s1){
calculate_pcondtional(s1)*calculate_pstudy1(s1)
}
integrate(integrand, lower=5.2, upper=Inf)
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=tempSd)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#probability of s2 replicating given s1
#the the two are multivate normal so we can use the equation
#each s1 has a different distbrution for s2 will be and then we want the probability of that replicating
calculate_pcondtional<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-1-pnorm(5.2, mean, sqrt(var))
return(p)
}
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))
}
integrand <- function(s1){
calculate_pcondtional(s1)*calculate_pstudy1(s1)
}
integrate(integrand, lower=5.2, upper=Inf)
#actual results of simulation
# number of s1 greater than 5.2
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=tempSd)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#probability of s2 replicating given s1
#the the two are multivate normal so we can use the equation
#each s1 has a different distbrution for s2 will be and then we want the probability of that replicating
calculate_pcondtional<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-1-pnorm(5.2, mean, sqrt(var))
return(p)
}
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))
}
integrand <- function(s1){
calculate_pcondtional(s1)*calculate_pstudy1(s1)
}
integrate(integrand, lower=5.2, upper=Inf)
#actual results of simulation
# number of s1 greater than 5.2
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=tempSd)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
View(results.data)
View(results.data)
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=sigma)
library(tidyverse)
library(MASS)
library(ggplot2)
library(dplyr)
library(plyr)
library(reshape2)
sigma<-sqrt(2)
N=10000
lamda <- rnorm(n=N, mean=0, sd=sigma)
results<-matrix(nrow=N, ncol=3)
for(i in 1:N){
results[i,1] = lamda[i]
results[i,c(2,3)] <- rnorm(n=2,mean=lamda[i],sd=1)
}
results.data=as.data.frame(results)
colnames(results.data)=c("lamda", "s1", "s2")
true_lambda <- function(lambda){
return(lambda)
}
#probability of s2 replicating given s1
#the the two are multivate normal so we can use the equation
#each s1 has a different distbrution for s2 will be and then we want the probability of that replicating
calculate_pcondtional<-function(s1){
mean<-(sigma^2*s1)/(1+sigma^2)
var=1+((sigma^2)/(1+sigma^2))
p<-1-pnorm(5.2, mean, sqrt(var))
return(p)
}
calculate_pstudy1<-function(s1){
dnorm(s1,0,sqrt(1+sigma^2))
}
integrand <- function(s1){
calculate_pcondtional(s1)*calculate_pstudy1(s1)
}
integrate(integrand, lower=5.2, upper=Inf)
#actual results of simulation
# number of s1 greater than 5.2
s1_sig<-nrow(filter(results.data, s1>5.2))
s2_sig_givens1<-nrow(filter(filter(results.data, s1>5.2), s2>5.2))
repRate=s2_sig_givens1/s1_sig
?subset
View(results.data)
View(results.data)
vector_s1,<-subset(results.data, s1>5.2 & s1<6)$s1
vector_s1<-subset(results.data, s1>5.2 & s1<6)$s1
1000000*.0038
1000000*.00039
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))
View(probabilties_conditional)
View(probabilties_conditional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))+
geom_point()+stat_function(fun=calculate_pcondtional(x))
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))+
geom_point()+stat_function(fun=calculate_pcondtional())
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))+
geom_point()+stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<9), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>0 & s1<5.2), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional<-ggplot(data=filter(results.data, s1>0 & s1<5.2), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>0 & s1<6), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>0 & s1<100), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
mean<-function(s1){
(sigma^2*s1)/(1+sigma^2)
}
means_conditional<-ggplot(data=filter(results.data, s1>0 & s1<100), mapping = aes(x=s1))+
stat_function(fun=mean)
means_conditional
means_conditional<-ggplot(data=filter(results.data, s1>5.2 & s1<6), mapping = aes(x=s1))+
stat_function(fun=mean)
means_conditional
probabilties_conditional<-ggplot(data=filter(results.data, s1>0 & s1<100), mapping = aes(x=s1))+
stat_function(fun=calculate_pcondtional)
probabilties_conditional
